#!/usr/bin/env perl
use strict;
use warnings;

my $HELP = <<'EOF';
Usage: goenv download [options] [version]

Options:
  -l, --list      show available versions (latest stable 10)
  -g, --global    executing `goenv globa` after installation
  -L, --list-all  show available versions (all)
  -h, --help      show this help

Examples:
 $ goenv download -l
 $ goenv download latest
 $ goenv download 1.17.3
 $ goenv download HEAD              # download golang source code, and build HEAD
 $ goenv download source@6f42be78bb # download golang source code, and build commit 6f42be78bb
EOF

{
    package App;

    use File::Basename qw(basename);
    use File::Path qw(mkpath);
    use File::Spec::Functions qw(catfile);
    use File::pushd qw(pushd);
    use Getopt::Long ();
    use HTTP::Tinyish;
    use POSIX qw(uname strftime);

    sub new {
        my ($class, %argv) = @_;
        my $home = $argv{home};
        my $cache_dir = catfile $home, "cache";
        my $root = $ENV{GOENV_ROOT} || catfile($ENV{HOME}, ".goenv");
        my $versions_dir = catfile $root, "versions";
        mkpath $_ for grep { !-d } $versions_dir, $cache_dir;
        my $os = $^O =~ /linux/i ? "linux" : $^O =~ /darwin/i ? "darwin" : die;
        my $_arch = (uname)[4];
        my $arch = $_arch eq "x86_64" ? "amd64" : $_arch eq "arm64" ? "arm64" : die;
        bless {
            os => $os,
            arch => $arch,
            home => $home,
            cache_dir => $cache_dir,
            root => $root,
            versions_dir => $versions_dir,
            http => HTTP::Tinyish->new(verify_SSL => 1),
        }, $class;
    }

    sub run {
        my ($self, @argv) = @_;

        my $parser = Getopt::Long::Parser->new(
            config => [qw(no_auto_abbrev no_ignore_case bundling)],
        );
        $parser->getoptionsfromarray(
            \@argv,
            "h|help" => sub { die $HELP },
            "l|list" => \my $list,
            "g|global" => \my $global,
            "L|list-all" => \my $list_all,
            "complete" => sub { print $_, "\n" for "-l", "-L", "latest"; exit 0 },
        ) or return 1;

        if ($list || $list_all) {
            my @available = $self->available;
            if ($list) {
                @available = (map { $_->{str} } grep { !$_->{rc_kind} } @available)[0..9];
            } else {
                @available = map { $_->{str} } @available;
            }
            print $_, "\n" for @available;
            return 0;
        }

        my $version = shift @argv or die "Need version, try `goenv download --help`\n";

        if ($version eq "HEAD" || $version =~ s/source@//) {
            $self->build_from_source($version);
            return 0;
        }

        my @available = $self->available;
        if ($version eq "latest") {
            $version = (map { $_->{str} } grep { !$_->{rc_kind} } @available)[0];
        } else {
            my %available = map { $_ => 1 } map { $_->{str} } $self->available;
            if (!$available{$version}) {
                die "Unknown version '$version', try `goenv download -L`\n";
            }
        }
        my $target = catfile $self->{versions_dir}, $version;
        if (-e $target) {
            die "Already exists $target\n";
        }
        my $tarball = $self->download($version);
        $self->unpack($tarball => $target);
        $self->log("Successfully installed $target");
        if ($global) {
            $self->log("Executing `goenv global $version`");
            !system "goenv", "global", $version or die;
        }
        return 0;
    }

    sub log { my $self = shift; warn "@_\n" }

    sub available {
        my $self = shift;
        my $url = "https://go.googlesource.com/go/+refs/tags?format=TEXT";
        my $res = $self->{http}->get($url);
        die "$res->{status} $url\n" if !$res->{success};
        my %seen;
        my @version;
        for my $line (split /\n/, $res->{content}) {
            # 6c15c7cce718e1e9a47f4f0ab1bd70923b04557b refs/tags/go1.12.10
            my (undef, $tag) = split /\s+/, $line, 2;
            if (my ($str, $major, $minor, $other) = $tag =~ m{^refs/tags/go((\d+)\.(\d+)(?:([0-9a-zA-Z.]+))?)$}) {
                my ($patch, $rc_kind, $rc_num) = (0, undef, 0);
                if ($other) {
                    $other =~ s/^\.//;
                    if ($other =~ s/^(\d+)//) {
                        $patch = $1;
                    }
                    if ($other =~ /^(rc|beta|alpha)(?:\d+)$/) {
                        $rc_kind = $1;
                        $rc_num = $2 || 0;
                    }
                }
                $seen{$str}++ and next;
                my $version = sprintf "%d.%03d%03d", $major, $minor, $patch;
                push @version, { version => $version, str => $str, rc_kind => $rc_kind, rc_num => $rc_num };
            }
        }
        my $sort_by = sub {
            my ($a, $b) = @_;
            if (my $ret = $a->{version} <=> $b->{version}) {
                return $ret;
            }
            my %kind = ( alpha => 1, beta => 2, rc => 3 );
            my ($rc_kind_a, $rc_kind_b) = ($a->{rc_kind}, $b->{rc_kind});
            if ($rc_kind_a && !$rc_kind_b) {
                return -1;
            } elsif (!$rc_kind_a && $rc_kind_b) {
                return 1;
            } elsif (my $ret = $kind{$rc_kind_a} <=> $kind{$rc_kind_b}) {
                return $ret;
            }
            return $a->{rc_num} <=> $b->{rc_num};
        };
        reverse sort { $sort_by->($a, $b) } @version;
    }

    sub download {
        my ($self, $version) = @_;
        my $url = sprintf "https://dl.google.com/go/go%s.%s-%s.tar.gz",
            $version, $self->{os}, $self->{arch};
        my $cache_file = catfile $self->{cache_dir}, basename($url);
        if (-f $cache_file) {
            $self->log("Using cache $cache_file");
            return $cache_file;
        }
        $self->log("Downloading $url");
        my $res = $self->{http}->mirror($url => $cache_file);
        if (!$res->{success}) {
            unlink $cache_file;
            die "$res->{status} $res->{reason}, $url\n";
        }
        $cache_file;
    }

    sub unpack {
        my ($self, $tarball, $target) = @_;
        mkpath $target;
        $self->log("Unpacking $tarball");
        !system "tar", "xf", $tarball, "--strip-components=1", "-C", $target or die;
    }

    sub build_from_source {
        my ($self, $commitish) = @_;

        my $url = "https://github.com/golang/go";

        my $reference = catfile $self->{cache_dir}, "reference";
        if (-d $reference) {
            my $guard = pushd $reference;
            my @cmd = ("git", "pull");
            $self->log("Updating $reference");
            !system @cmd or die;
        } else {
            my @cmd = ("git", "clone", "-q", $url, $reference);
            $self->log("Executing @cmd");
            !system @cmd or die;
        }

        if ($commitish eq "HEAD") {
            my $guard = pushd $reference;
            $commitish = `git rev-parse --short HEAD`;
            chomp $commitish;
        }
        my $target = catfile $self->{versions_dir}, strftime("%Y%m%d-", localtime) . $commitish;

        my @cmd = ("git", "clone", "-q", "--reference", $reference, $url, $target);
        $self->log("Executing @cmd");
        !system @cmd or die;

        my $guard = pushd $target;
        @cmd = ("git", "checkout", "-q", $commitish);
        $self->log("Executing @cmd");
        !system @cmd or die;

        {
            my $guard = pushd "src";
            my @cmd = ("bash", "make.bash");
            $self->log("Executing @cmd");
            !system @cmd or die;
        }

        @cmd = ("bin/go", "install", "-race", "std");
        $self->log("Executing @cmd");
        !system @cmd or die;
    }
}

use Cwd qw(abs_path);
use File::Spec::Functions qw(catfile);
use FindBin qw($Bin);

my $home = abs_path(catfile($Bin, ".."));
my $app = App->new(home => $home);
exit $app->run(@ARGV);
